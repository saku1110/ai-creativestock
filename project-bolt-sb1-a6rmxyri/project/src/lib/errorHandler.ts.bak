import { auditLogger } from './auditLogger';

// 繧ｨ繝ｩ繝ｼ繧ｿ繧､繝励・螳夂ｾｩ
export enum ErrorType {
  AUTHENTICATION = 'authentication',
  AUTHORIZATION = 'authorization',
  VALIDATION = 'validation',
  NETWORK = 'network',
  DATABASE = 'database',
  FILE_UPLOAD = 'file_upload',
  RATE_LIMIT = 'rate_limit',
  SECURITY = 'security',
  UNKNOWN = 'unknown'
}

// 繧ｨ繝ｩ繝ｼ繝ｬ繝吶Ν縺ｮ螳夂ｾｩ
export enum ErrorLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// 繧ｫ繧ｹ繧ｿ繝繧ｨ繝ｩ繝ｼ繧ｯ繝ｩ繧ｹ
export class AppError extends Error {
  public readonly type: ErrorType;
  public readonly level: ErrorLevel;
  public readonly code: string;
  public readonly userId?: string;
  public readonly context?: Record<string, any>;
  public readonly timestamp: string;
  public readonly retryable: boolean;

  constructor(
    message: string,
    type: ErrorType = ErrorType.UNKNOWN,
    level: ErrorLevel = ErrorLevel.MEDIUM,
    code?: string,
    userId?: string,
    context?: Record<string, any>,
    retryable = false
  ) {
    super(message);
    this.name = 'AppError';
    this.type = type;
    this.level = level;
    this.code = code || type.toUpperCase();
    this.userId = userId;
    this.context = context;
    this.timestamp = new Date().toISOString();
    this.retryable = retryable;

    // 繧ｹ繧ｿ繝・け繝医Ξ繝ｼ繧ｹ繧剃ｿ晄戟
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AppError);
    }
  }
}

// 繧ｨ繝ｩ繝ｼ繝上Φ繝峨Λ繝ｼ縺ｮ險ｭ螳・interface ErrorHandlerConfig {
  enableConsoleLogging: boolean;
  enableAuditLogging: boolean;
  enableUserNotification: boolean;
  enableRetry: boolean;
  maxRetryAttempts: number;
  sentryDsn?: string;
}

export class ErrorHandler {
  private static instance: ErrorHandler;
  private config: ErrorHandlerConfig;
  private retryAttempts: Map<string, number> = new Map();

  private constructor(config: Partial<ErrorHandlerConfig> = {}) {
    this.config = {
      enableConsoleLogging: true,
      enableAuditLogging: true,
      enableUserNotification: true,
      enableRetry: true,
      maxRetryAttempts: 3,
      ...config
    };

    this.setupGlobalErrorHandlers();
  }

  public static getInstance(config?: Partial<ErrorHandlerConfig>): ErrorHandler {
    if (!ErrorHandler.instance) {
      ErrorHandler.instance = new ErrorHandler(config);
    }
    return ErrorHandler.instance;
  }

  // 繧ｰ繝ｭ繝ｼ繝舌Ν繧ｨ繝ｩ繝ｼ繝上Φ繝峨Λ繝ｼ縺ｮ險ｭ螳・  private setupGlobalErrorHandlers(): void {
    if (typeof window !== 'undefined') {
      // 譛ｪ蜃ｦ逅・・Promise諡貞凄
      window.addEventListener('unhandledrejection', (event) => {
        const error = new AppError(
          `譛ｪ蜃ｦ逅・・Promise諡貞凄: ${event.reason}`,
          ErrorType.UNKNOWN,
          ErrorLevel.HIGH,
          'UNHANDLED_PROMISE_REJECTION'
        );
        this.handleError(error);
        event.preventDefault();
      });

      // JavaScript 繧ｨ繝ｩ繝ｼ
      window.addEventListener('error', (event) => {
        const error = new AppError(
          `JavaScript 繧ｨ繝ｩ繝ｼ: ${event.message}`,
          ErrorType.UNKNOWN,
          ErrorLevel.MEDIUM,
          'JAVASCRIPT_ERROR',
          undefined,
          {
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno
          }
        );
        this.handleError(error);
      });
    }
  }

  // 繧ｨ繝ｩ繝ｼ繝上Φ繝峨Μ繝ｳ繧ｰ縺ｮ荳ｭ譬ｸ繝｡繧ｽ繝・ラ
  public async handleError(error: Error | AppError, userId?: string, additionalContext?: Record<string, any>): Promise<void> {
    let appError: AppError;

    // AppError縺ｧ縺ｪ縺・ｴ蜷医・螟画鋤
    if (!(error instanceof AppError)) {
      appError = this.convertToAppError(error, userId, additionalContext);
    } else {
      appError = error;
      if (userId && !appError.userId) {
        appError = new AppError(
          appError.message,
          appError.type,
          appError.level,
          appError.code,
          userId,
          { ...appError.context, ...additionalContext },
          appError.retryable
        );
      }
    }

    // 繧ｳ繝ｳ繧ｽ繝ｼ繝ｫ繝ｭ繧ｰ
    if (this.config.enableConsoleLogging) {
      this.logToConsole(appError);
    }

    // 逶｣譟ｻ繝ｭ繧ｰ
    if (this.config.enableAuditLogging) {
      await this.logToAuditSystem(appError);
    }

    // 繝ｦ繝ｼ繧ｶ繝ｼ騾夂衍
    if (this.config.enableUserNotification) {
      this.notifyUser(appError);
    }

    // 螟夜Κ繧ｵ繝ｼ繝薙せ騾夂衍・・entry遲会ｼ・    if (this.config.sentryDsn) {
      this.reportToExternalService(appError);
    }

    // 繝ｪ繝医Λ繧､蜃ｦ逅・    if (this.config.enableRetry && appError.retryable) {
      await this.handleRetry(appError);
    }
  }

  // 繧ｨ繝ｩ繝ｼ繧但ppError縺ｫ螟画鋤
  private convertToAppError(error: Error, userId?: string, context?: Record<string, any>): AppError {
    let type = ErrorType.UNKNOWN;
    let level = ErrorLevel.MEDIUM;
    let code = 'UNKNOWN_ERROR';
    let retryable = false;

    // 繧ｨ繝ｩ繝ｼ繝｡繝・そ繝ｼ繧ｸ繧・ち繧､繝励°繧牙・鬘・    const message = error.message.toLowerCase();

    if (message.includes('network') || message.includes('fetch')) {
      type = ErrorType.NETWORK;
      retryable = true;
    } else if (message.includes('auth') || message.includes('unauthorized')) {
      type = ErrorType.AUTHENTICATION;
      level = ErrorLevel.HIGH;
    } else if (message.includes('permission') || message.includes('forbidden')) {
      type = ErrorType.AUTHORIZATION;
      level = ErrorLevel.HIGH;
    } else if (message.includes('validation') || message.includes('invalid')) {
      type = ErrorType.VALIDATION;
      level = ErrorLevel.LOW;
    } else if (message.includes('database') || message.includes('sql')) {
      type = ErrorType.DATABASE;
      level = ErrorLevel.HIGH;
      retryable = true;
    } else if (message.includes('rate limit') || message.includes('too many')) {
      type = ErrorType.RATE_LIMIT;
      level = ErrorLevel.MEDIUM;
    } else if (message.includes('security') || message.includes('csrf') || message.includes('xss')) {
      type = ErrorType.SECURITY;
      level = ErrorLevel.CRITICAL;
    }

    return new AppError(
      error.message,
      type,
      level,
      code,
      userId,
      {
        originalError: error.name,
        stack: error.stack,
        ...context
      },
      retryable
    );
  }

  // 繧ｳ繝ｳ繧ｽ繝ｼ繝ｫ繝ｭ繧ｰ蜃ｺ蜉・  private logToConsole(error: AppError): void {
    const logLevel = error.level === ErrorLevel.CRITICAL ? 'error' :
                    error.level === ErrorLevel.HIGH ? 'warn' : 'info';

    console[logLevel](`[ERROR] ${error.type.toUpperCase()}: ${error.message}`, {
      code: error.code,
      level: error.level,
      userId: error.userId,
      timestamp: error.timestamp,
      context: error.context,
      stack: error.stack
    });
  }

  // 逶｣譟ｻ繝ｭ繧ｰ繧ｷ繧ｹ繝・Β縺ｫ險倬鹸
  private async logToAuditSystem(error: AppError): Promise<void> {
    try {
      const context = {
        userId: error.userId,
        additional: {
          error_code: error.code,
          error_level: error.level,
          error_type: error.type,
          retryable: error.retryable,
          timestamp: error.timestamp,
          ...error.context
        }
      };

      auditLogger.logError(error, context, 'error_occurred', 'error_handling');
    } catch (auditError) {
      console.error('逶｣譟ｻ繝ｭ繧ｰ險倬鹸繧ｨ繝ｩ繝ｼ:', auditError);
    }
  }

  // 繝ｦ繝ｼ繧ｶ繝ｼ縺ｸ縺ｮ騾夂衍
  private notifyUser(error: AppError): void {
    // 髢狗匱迺ｰ蠅・〒縺ｯ騾夂衍繧堤┌蜉ｹ蛹・    if (import.meta.env.DEV || import.meta.env.VITE_APP_ENV === 'development') {
      console.log(`[DEV] 繧ｨ繝ｩ繝ｼ騾夂衍繧堤┌蜉ｹ蛹・ ${error.message}`);
      return;
    }

    let userMessage = '繧ｷ繧ｹ繝・Β繧ｨ繝ｩ繝ｼ縺檎匱逕溘＠縺ｾ縺励◆縲ゅ＠縺ｰ繧峨￥譎る俣繧偵♀縺・※蜀榊ｺｦ縺願ｩｦ縺励￥縺縺輔＞縲・;

    switch (error.type) {
      case ErrorType.AUTHENTICATION:
        userMessage = '繝ｭ繧ｰ繧､繝ｳ縺ｮ譛牙柑譛滄剞縺悟・繧後∪縺励◆縲ょ・蠎ｦ繝ｭ繧ｰ繧､繝ｳ縺励※縺上□縺輔＞縲・;
        break;
      case ErrorType.AUTHORIZATION:
        userMessage = '縺薙・謫堺ｽ懊ｒ螳溯｡後☆繧区ｨｩ髯舌′縺ゅｊ縺ｾ縺帙ｓ縲・;
        break;
      case ErrorType.VALIDATION:
        userMessage = '蜈･蜉帛・螳ｹ縺ｫ隱､繧翫′縺ゅｊ縺ｾ縺吶ら｢ｺ隱阪＠縺ｦ蜀榊ｺｦ縺願ｩｦ縺励￥縺縺輔＞縲・;
        break;
      case ErrorType.NETWORK:
        userMessage = '繝阪ャ繝医Ρ繝ｼ繧ｯ謗･邯壹↓蝠城｡後′縺ゅｊ縺ｾ縺吶ゅう繝ｳ繧ｿ繝ｼ繝阪ャ繝域磁邯壹ｒ遒ｺ隱阪＠縺ｦ縺上□縺輔＞縲・;
        break;
      case ErrorType.FILE_UPLOAD:
        userMessage = '繝輔ぃ繧､繝ｫ縺ｮ繧｢繝・・繝ｭ繝ｼ繝峨↓螟ｱ謨励＠縺ｾ縺励◆縲ゅヵ繧｡繧､繝ｫ蠖｢蠑上ｄ繧ｵ繧､繧ｺ繧堤｢ｺ隱阪＠縺ｦ縺上□縺輔＞縲・;
        break;
      case ErrorType.RATE_LIMIT:
        userMessage = '繝ｪ繧ｯ繧ｨ繧ｹ繝医′螟壹☆縺弱∪縺吶ゅ＠縺ｰ繧峨￥譎る俣繧偵♀縺・※蜀榊ｺｦ縺願ｩｦ縺励￥縺縺輔＞縲・;
        break;
    }

    // 繝ｦ繝ｼ繧ｶ繝ｼ繝輔Ξ繝ｳ繝峨Μ繝ｼ縺ｪ繧ｨ繝ｩ繝ｼ陦ｨ遉ｺ
    if (error.level === ErrorLevel.LOW) {
      console.info(userMessage);
    } else {
      alert(userMessage);
    }
  }

  // 螟夜Κ繧ｵ繝ｼ繝薙せ縺ｸ縺ｮ蝣ｱ蜻・  private reportToExternalService(error: AppError): void {
    // Sentry縲。ugsnag縲．ataDog遲峨∈縺ｮ蝣ｱ蜻・    if (this.config.sentryDsn && typeof window !== 'undefined' && (window as any).Sentry) {
      (window as any).Sentry.captureException(error, {
        tags: {
          error_type: error.type,
          error_level: error.level,
          error_code: error.code
        },
        user: error.userId ? { id: error.userId } : undefined,
        extra: error.context
      });
    }
  }

  // 繝ｪ繝医Λ繧､蜃ｦ逅・  private async handleRetry(error: AppError): Promise<void> {
    if (!error.retryable) return;

    const retryKey = `${error.code}_${error.userId || 'anonymous'}`;
    const currentAttempts = this.retryAttempts.get(retryKey) || 0;

    if (currentAttempts >= this.config.maxRetryAttempts) {
      console.warn(`譛螟ｧ繝ｪ繝医Λ繧､蝗樊焚縺ｫ驕斐＠縺ｾ縺励◆: ${error.message}`);
      this.retryAttempts.delete(retryKey);
      return;
    }

    this.retryAttempts.set(retryKey, currentAttempts + 1);

    // 謖・焚繝舌ャ繧ｯ繧ｪ繝輔〒繝ｪ繝医Λ繧､
    const delay = Math.pow(2, currentAttempts) * 1000;
    setTimeout(() => {
      console.log(`繝ｪ繝医Λ繧､荳ｭ (${currentAttempts + 1}/${this.config.maxRetryAttempts}): ${error.message}`);
      // 縺薙％縺ｧ螳滄圀縺ｮ繝ｪ繝医Λ繧､繝ｭ繧ｸ繝・け繧貞ｮ溯｣・    }, delay);
  }

  // 繧ｨ繝ｩ繝ｼ邨ｱ險医・蜿門ｾ・  public getErrorStatistics(timeRange: 'hour' | 'day' | 'week' = 'day'): {
    totalErrors: number;
    errorsByType: Record<string, number>;
    errorsByLevel: Record<string, number>;
    topErrors: Array<{ message: string; count: number }>;
  } {
    // 螳溯｣・・逶｣譟ｻ繝ｭ繧ｰ繧ｷ繧ｹ繝・Β縺ｨ騾｣謳ｺ
    return {
      totalErrors: 0,
      errorsByType: {},
      errorsByLevel: {},
      topErrors: []
    };
  }

  // 險ｭ螳壹・譖ｴ譁ｰ
  public updateConfig(newConfig: Partial<ErrorHandlerConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }

  // 繝ｪ繝医Λ繧､繧ｫ繧ｦ繝ｳ繧ｿ繝ｼ縺ｮ繧ｯ繝ｪ繧｢
  public clearRetryAttempts(): void {
    this.retryAttempts.clear();
  }
}

// 繧ｰ繝ｭ繝ｼ繝舌Ν繧ｨ繝ｩ繝ｼ繝上Φ繝峨Λ繝ｼ縺ｮ繧､繝ｳ繧ｹ繧ｿ繝ｳ繧ｹ
export const globalErrorHandler = ErrorHandler.getInstance();

// 繝倥Ν繝代・髢｢謨ｰ
export const handleAsyncError = async (
  operation: () => Promise<any>,
  errorType: ErrorType = ErrorType.UNKNOWN,
  userId?: string,
  context?: Record<string, any>
): Promise<any> => {
  try {
    return await operation();
  } catch (error) {
    const appError = new AppError(
      error instanceof Error ? error.message : String(error),
      errorType,
      ErrorLevel.MEDIUM,
      undefined,
      userId,
      context,
      true
    );
    await globalErrorHandler.handleError(appError);
    throw appError;
  }
};

// React 繧ｨ繝ｩ繝ｼ繝舌え繝ｳ繝繝ｪ逕ｨ縺ｮ繧ｨ繝ｩ繝ｼ繝上Φ繝峨Λ繝ｼ
export const handleReactError = (error: Error, errorInfo: any, userId?: string) => {
  const appError = new AppError(
    error.message,
    ErrorType.UNKNOWN,
    ErrorLevel.HIGH,
    'REACT_ERROR',
    userId,
    {
      componentStack: errorInfo.componentStack,
      errorBoundary: true
    }
  );
  globalErrorHandler.handleError(appError);
};
