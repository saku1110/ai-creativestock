    } else if (message.includes('rate limit') || message.includes('too many')) {
      type = ErrorType.RATE_LIMIT;
      level = ErrorLevel.MEDIUM;
    } else if (message.includes('security') || message.includes('csrf') || message.includes('xss')) {
      type = ErrorType.SECURITY;
      level = ErrorLevel.CRITICAL;
    }

    return new AppError(
      error.message,
      type,
      level,
      code,
      userId,
      {
        originalError: error.name,
        stack: error.stack,
        ...context
      },
      retryable
    );
  }

  // 繧ｳ繝ｳ繧ｽ繝ｼ繝ｫ繝ｭ繧ｰ蜃ｺ蜉・  private logToConsole(error: AppError): void {
    const logLevel = error.level === ErrorLevel.CRITICAL ? 'error' :
                    error.level === ErrorLevel.HIGH ? 'warn' : 'info';

    console[logLevel](`[ERROR] ${error.type.toUpperCase()}: ${error.message}`, {
      code: error.code,
      level: error.level,
      userId: error.userId,
      timestamp: error.timestamp,
      context: error.context,
      stack: error.stack
    });
  }

  // 逶｣譟ｻ繝ｭ繧ｰ繧ｷ繧ｹ繝・Β縺ｫ險倬鹸
  private async logToAuditSystem(error: AppError): Promise<void> {
    try {
      const context = {
        userId: error.userId,
        additional: {
          error_code: error.code,
          error_level: error.level,
          error_type: error.type,
          retryable: error.retryable,
          timestamp: error.timestamp,
          ...error.context
        }
      };

      auditLogger.logError(error, context, 'error_occurred', 'error_handling');
    } catch (auditError) {
      console.error('逶｣譟ｻ繝ｭ繧ｰ險倬鹸繧ｨ繝ｩ繝ｼ:', auditError);
    }
  }

  // 繝ｦ繝ｼ繧ｶ繝ｼ縺ｸ縺ｮ騾夂衍
  private notifyUser(error: AppError): void {
    // 髢狗匱迺ｰ蠅・〒縺ｯ騾夂衍繧堤┌蜉ｹ蛹・    if (import.meta.env.DEV || import.meta.env.VITE_APP_ENV === 'development') {
      console.log(`[DEV] 繧ｨ繝ｩ繝ｼ騾夂衍繧堤┌蜉ｹ蛹・ ${error.message}`);
      return;
    }

    let userMessage = '繧ｷ繧ｹ繝・Β繧ｨ繝ｩ繝ｼ縺檎匱逕溘＠縺ｾ縺励◆縲ゅ＠縺ｰ繧峨￥譎る俣繧偵♀縺・※蜀榊ｺｦ縺願ｩｦ縺励￥縺縺輔＞縲・;

    switch (error.type) {
      case ErrorType.AUTHENTICATION:
        userMessage = '繝ｭ繧ｰ繧､繝ｳ縺ｮ譛牙柑譛滄剞縺悟・繧後∪縺励◆縲ょ・蠎ｦ繝ｭ繧ｰ繧､繝ｳ縺励※縺上□縺輔＞縲・;
        break;
      case ErrorType.AUTHORIZATION:
        userMessage = '縺薙・謫堺ｽ懊ｒ螳溯｡後☆繧区ｨｩ髯舌′縺ゅｊ縺ｾ縺帙ｓ縲・;
        break;
      case ErrorType.VALIDATION:
        userMessage = '蜈･蜉帛・螳ｹ縺ｫ隱､繧翫′縺ゅｊ縺ｾ縺吶ら｢ｺ隱阪＠縺ｦ蜀榊ｺｦ縺願ｩｦ縺励￥縺縺輔＞縲・;
        break;
      case ErrorType.NETWORK:
        userMessage = '繝阪ャ繝医Ρ繝ｼ繧ｯ謗･邯壹↓蝠城｡後′縺ゅｊ縺ｾ縺吶ゅう繝ｳ繧ｿ繝ｼ繝阪ャ繝域磁邯壹ｒ遒ｺ隱阪＠縺ｦ縺上□縺輔＞縲・;
        break;
      case ErrorType.FILE_UPLOAD:
        userMessage = '繝輔ぃ繧､繝ｫ縺ｮ繧｢繝・・繝ｭ繝ｼ繝峨↓螟ｱ謨励＠縺ｾ縺励◆縲ゅヵ繧｡繧､繝ｫ蠖｢蠑上ｄ繧ｵ繧､繧ｺ繧堤｢ｺ隱阪＠縺ｦ縺上□縺輔＞縲・;
        break;
      case ErrorType.RATE_LIMIT:
        userMessage = '繝ｪ繧ｯ繧ｨ繧ｹ繝医′螟壹☆縺弱∪縺吶ゅ＠縺ｰ繧峨￥譎る俣繧偵♀縺・※蜀榊ｺｦ縺願ｩｦ縺励￥縺縺輔＞縲・;
        break;
    }

    // 繝ｦ繝ｼ繧ｶ繝ｼ繝輔Ξ繝ｳ繝峨Μ繝ｼ縺ｪ繧ｨ繝ｩ繝ｼ陦ｨ遉ｺ
    if (error.level === ErrorLevel.LOW) {
      console.info(userMessage);
    } else {
      alert(userMessage);
    }
  }

  // 螟夜Κ繧ｵ繝ｼ繝薙せ縺ｸ縺ｮ蝣ｱ蜻・  private reportToExternalService(error: AppError): void {
    // Sentry縲。ugsnag縲．ataDog遲峨∈縺ｮ蝣ｱ蜻・    if (this.config.sentryDsn && typeof window !== 'undefined' && (window as any).Sentry) {
      (window as any).Sentry.captureException(error, {
        tags: {
          error_type: error.type,
          error_level: error.level,
          error_code: error.code
        },
        user: error.userId ? { id: error.userId } : undefined,
        extra: error.context
      });
    }
  }

  // 繝ｪ繝医Λ繧､蜃ｦ逅・  private async handleRetry(error: AppError): Promise<void> {
    if (!error.retryable) return;

    const retryKey = `${error.code}_${error.userId || 'anonymous'}`;
    const currentAttempts = this.retryAttempts.get(retryKey) || 0;

    if (currentAttempts >= this.config.maxRetryAttempts) {
      console.warn(`譛螟ｧ繝ｪ繝医Λ繧､蝗樊焚縺ｫ驕斐＠縺ｾ縺励◆: ${error.message}`);
      this.retryAttempts.delete(retryKey);
      return;
    }

    this.retryAttempts.set(retryKey, currentAttempts + 1);

    // 謖・焚繝舌ャ繧ｯ繧ｪ繝輔〒繝ｪ繝医Λ繧､
    const delay = Math.pow(2, currentAttempts) * 1000;
    setTimeout(() => {
      console.log(`繝ｪ繝医Λ繧､荳ｭ (${currentAttempts + 1}/${this.config.maxRetryAttempts}): ${error.message}`);
      // 縺薙％縺ｧ螳滄圀縺ｮ繝ｪ繝医Λ繧､繝ｭ繧ｸ繝・け繧貞ｮ溯｣・    }, delay);
  }

  // 繧ｨ繝ｩ繝ｼ邨ｱ險医・蜿門ｾ・  public getErrorStatistics(timeRange: 'hour' | 'day' | 'week' = 'day'): {
    totalErrors: number;
    errorsByType: Record<string, number>;
    errorsByLevel: Record<string, number>;
    topErrors: Array<{ message: string; count: number }>;
  } {
    // 螳溯｣・・逶｣譟ｻ繝ｭ繧ｰ繧ｷ繧ｹ繝・Β縺ｨ騾｣謳ｺ
    return {
      totalErrors: 0,
      errorsByType: {},
      errorsByLevel: {},
      topErrors: []
    };
  }

  // 險ｭ螳壹・譖ｴ譁ｰ
  public updateConfig(newConfig: Partial<ErrorHandlerConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }

  // 繝ｪ繝医Λ繧､繧ｫ繧ｦ繝ｳ繧ｿ繝ｼ縺ｮ繧ｯ繝ｪ繧｢
  public clearRetryAttempts(): void {
    this.retryAttempts.clear();
  }
}

// 繧ｰ繝ｭ繝ｼ繝舌Ν繧ｨ繝ｩ繝ｼ繝上Φ繝峨Λ繝ｼ縺ｮ繧､繝ｳ繧ｹ繧ｿ繝ｳ繧ｹ
export const globalErrorHandler = ErrorHandler.getInstance();

// 繝倥Ν繝代・髢｢謨ｰ
export const handleAsyncError = async (
  operation: () => Promise<any>,
  errorType: ErrorType = ErrorType.UNKNOWN,
  userId?: string,
  context?: Record<string, any>
): Promise<any> => {
  try {
    return await operation();
  } catch (error) {
    const appError = new AppError(
      error instanceof Error ? error.message : String(error),
      errorType,
      ErrorLevel.MEDIUM,
      undefined,
      userId,
      context,
      true
    );
    await globalErrorHandler.handleError(appError);
    throw appError;
  }
};

// React 繧ｨ繝ｩ繝ｼ繝舌え繝ｳ繝繝ｪ逕ｨ縺ｮ繧ｨ繝ｩ繝ｼ繝上Φ繝峨Λ繝ｼ
export const handleReactError = (error: Error, errorInfo: any, userId?: string) => {
  const appError = new AppError(
    error.message,
    ErrorType.UNKNOWN,
    ErrorLevel.HIGH,
    'REACT_ERROR',
    userId,
    {
      componentStack: errorInfo.componentStack,
      errorBoundary: true
    }
  );
  globalErrorHandler.handleError(appError);
};
