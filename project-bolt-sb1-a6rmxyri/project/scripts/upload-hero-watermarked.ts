#!/usr/bin/env tsx

/**
 * Uploads only watermarked hero videos (matching *-wm-alpha200.mp4) to Supabase Storage
 * after clearing existing objects under hero/ in the configured bucket.
 * Also regenerates src/local-content/remote-manifest.ts with the uploaded hero entries.
 *
 * Env vars (read via .env):
 *  - SUPABASE_URL (required)
 *  - SUPABASE_SERVICE_ROLE_KEY or SUPABASE_SERVICE_KEY (required)
 *  - SUPABASE_STORAGE_BUCKET (optional, default: local-content)
 */

import { createClient } from '@supabase/supabase-js';
import { config as loadEnv } from 'dotenv';
import fs from 'fs/promises';
import path from 'path';

loadEnv();

const supabaseUrl = process.env.SUPABASE_URL || process.env.VITE_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_KEY;
const bucket = process.env.SUPABASE_STORAGE_BUCKET || 'local-content';

if (!supabaseUrl || !serviceRoleKey) {
  console.error('SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY/SUPABASE_SERVICE_KEY are required');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, serviceRoleKey, {
  auth: { persistSession: false }
});

type ManifestEntry = {
  url: string;
  path: string;
  uploadedAt: string;
  size: number;
  mimeType: string;
};

const heroDir = path.resolve(process.cwd(), 'src', 'local-content', 'hero');
const manifestPath = path.resolve(process.cwd(), 'src', 'local-content', 'remote-manifest.ts');

async function listHeroObjects(): Promise<string[]> {
  // Supabase storage list is paginated; loop until empty
  const all: string[] = [];
  let offset = 0;
  const limit = 1000;
  while (true) {
    const { data, error } = await supabase.storage.from(bucket).list('hero', { limit, offset });
    if (error) throw error;
    const items = data || [];
    all.push(...items.filter(i => i.name).map(i => `hero/${i.name}`));
    if (items.length < limit) break;
    offset += items.length;
  }
  return all;
}

async function main() {
  // Find local watermarked hero files
  const entries = await fs.readdir(heroDir, { withFileTypes: true });
  const localFiles = entries
    .filter(e => e.isFile() && e.name.toLowerCase().endsWith('-wm-alpha200.mp4'))
    .map(e => path.join(heroDir, e.name));

  if (localFiles.length === 0) {
    console.log('No watermarked hero files (*-wm-alpha200.mp4) found. Nothing to upload.');
    return;
  }

  // Delete existing hero/* objects
  const existing = await listHeroObjects().catch(() => [] as string[]);
  if (existing.length > 0) {
    console.log(`Deleting ${existing.length} existing objects from ${bucket}/hero ...`);
    // Supabase remove accepts up to 1000 items per call
    const chunkSize = 1000;
    for (let i = 0; i < existing.length; i += chunkSize) {
      const chunk = existing.slice(i, i + chunkSize);
      const { error } = await supabase.storage.from(bucket).remove(chunk);
      if (error) throw error;
    }
  } else {
    console.log('No existing objects under hero/ to delete.');
  }

  // Upload local files
  const manifest: Record<string, ManifestEntry> = {};
  const sanitizeBasename = (name: string): string => {
    const idx = name.lastIndexOf('.');
    const base = idx >= 0 ? name.slice(0, idx) : name;
    const ext = idx >= 0 ? name.slice(idx) : '';
    let safe = base
      .normalize('NFKD')
      .replace(/[^A-Za-z0-9._-]+/g, '-')
      .replace(/-{2,}/g, '-')
      .replace(/^[-.]+|[-.]+$/g, '');
    if (!safe) safe = `file-${Date.now()}`;
    if (safe.length > 120) safe = safe.slice(0, 120);
    return `${safe}${ext}`;
  };

  for (const full of localFiles) {
    const base = path.basename(full);
    const storageBase = sanitizeBasename(base);
    const storagePath = `hero/${storageBase}`;
    const buf = await fs.readFile(full);
    const { error: upErr } = await supabase.storage
      .from(bucket)
      .upload(storagePath, buf, { upsert: true, contentType: 'video/mp4' });
    if (upErr) {
      console.error(`Failed to upload ${base}:`, upErr.message);
      continue;
    }
    const { data: pub } = supabase.storage.from(bucket).getPublicUrl(storagePath);
    const url = pub?.publicUrl || '';
    // Keep manifest key as original local name, but path as sanitized storage path
    manifest[`hero/${base}`] = {
      url,
      path: storagePath,
      uploadedAt: new Date().toISOString(),
      size: buf.byteLength,
      mimeType: 'video/mp4'
    };
    console.log(`Uploaded ${base}`);
  }

  // Write manifest (hero entries only)
  const header = `/**\n * This file is auto-generated by scripts/upload-hero-watermarked.ts\n * Do not edit manually.\n */\n\nexport const remoteManifest = ${JSON.stringify(manifest, null, 2)} as const;\n\nexport type RemoteManifest = typeof remoteManifest;\nexport type RemoteManifestEntry = RemoteManifest[keyof RemoteManifest];\n`;
  await fs.writeFile(manifestPath, header, 'utf8');
  console.log(`Manifest updated at ${path.relative(process.cwd(), manifestPath)}`);
}

main().catch((err) => {
  console.error('Upload script failed:', err);
  process.exit(1);
});
